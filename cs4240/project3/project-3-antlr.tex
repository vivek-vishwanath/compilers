\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage[includehead, margin=2cm]{geometry}
\usepackage{listings}
\usepackage{titling}
\usepackage{parskip}
\usepackage{fancyvrb}
\usepackage{tabularx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{syntax}
\usepackage[title]{appendix}

\hypersetup{
    colorlinks=true,
    urlcolor=blue
}
\lstset{basicstyle=\ttfamily,
  showstringspaces=false,
  commentstyle=\color{red},
  keywordstyle=\color{blue}
}

\pagestyle{fancy}

\newenvironment{centeredcode}
{
\ttfamily
\begin{center}
\begin{tabular}{l}
}
{
\end{tabular}
\end{center}
}

\newcommand{\semester}{Fall 2025}
\newcommand{\assigned}{October 29, 2025}
\newcommand{\due}{November 24, 2025}
\newcommand{\antlrver}{4.13.2}

\title{CS 4240: Compilers and Interpreters, Project 3, \semester\\
\Large
ANTLR Version \\
Assigned: \assigned, 5\% of course grade\\
Due in Gradescope by 11:59pm on \due
}
\preauthor{}
\postauthor{}
\author{}
\date{}

\begin{document}
\lhead{CS 4240, \semester}
\rhead{Project 3}
\maketitle
\thispagestyle{fancy}

\section{Overview}
In this project, you will build a {\bf lexer} and a {\bf parser} for the
\textbf{\emph{Tiger}} language.

\textbf{\emph{Tiger}} is a small
language with properties you are familiar with, including
functions, arrays, integer and float types, and control flow.
Syntactic and lexical specifications of the \emph{Tiger}
language are available in Appendix~\ref{app:tiger}. You will be using the \href{https://github.com/antlr/antlr4/blob/master/doc/getting-started.md}{\textbf{ANTLR v4}} tool to generate a lexer and a parser for the \emph{Tiger} language. You will write a program that invokes the generated lexer and parser.

\textbf{ANTLR v4} is a production tool used to generate lexers and parsers based on input lexical and syntactic  specifications. We recommend that you start by studying ANTLR using the examples and documentation that are provided with it. After that, you will be ready to build the lexer and parser for the  \emph{Tiger} language. Download the latest version of ANTLR (v\antlrver) from \url{https://www.antlr.org/download.html}.

A complete compiler front-end would also include symbol table creation, semantic analysis, and intermediate representation (IR) code generation, but you will \textbf{not} implement those components in this project.

\section{Project Steps}\label{steps}

The project repository is available at 

\url{https://github.gatech.edu/CS-4240-Fall-2025/Project-3-Antlr}. 

The \texttt{demo} directory in this repository contains a detailed readme file which additional guidance on building and using ANTLR.

\subsection{Lexer (Scanner)}

The lexer implements the lexical specification of \emph{Tiger}; it reads in the program's stream of characters (one character at a time) and returns the correct token on each request from the parser.

You will write the lexical specification of \emph{Tiger} (Appendix~\ref{app:lexical}) in a form acceptable to ANTLR and generate the lexer program in one of the following languages: Java, C++, C\#, Python.

You will then test it for errors and correct production of stream of tokens. As far as the errors are concerned, you can just produce the errors generated by the ANTLR generated lexer.

For lexically malformed \emph{Tiger} programs, your lexer will throw an error which prints the line number in the file, the partial prefix of the erroneous string, and the malformed token with the culprit character that caused the error. The lexer is capable of catching multiple errors in one pass; i.e., it does not quit but continues on after catching the first error. It will throw away the bad characters and restart token generation from the next character that starts a legal token in \emph{Tiger}.

Some notes on the lexer:  
\begin{itemize}
\item Keywords are recognized as a subset of the identifiers---that is, first the lexer recognizes an identifier (ID) and then checks the string against a list of keywords. If it matches, it returns the  corresponding keyword token and not an ID. 
\item The lexer uses the \textbf{longest match algorithm} when recognizing tokens. That is, the lexer keeps matching the input characters to the current token until it encounters one which is not a part of the current token. At this point, the token is completed using the last legal character and is returned to the parser. Next time around, the token generation restarts from the first character which was not the part of the last token.
\end{itemize}

\subsection{Parser}
The parser implements the syntactic specification of \textit{Tiger}. Rewrite the grammar provided in Appendix~\ref{app:grammar} and use the new grammar as an input to ANTLR, in order to generate a parser that invokes your lexer to generate tokens.
This part of the project consists of three parts.
\begin{enumerate}
\item \textbf{Remove ambiguity.} You must rewrite the grammar to remove any ambiguity by enforcing operator precedences and left/right associativity for different operators. A grammar is ambiguous if it can produce two or more distinct parse trees for the same input sentence. You can either manually modify the grammar by hand or write code that manipulates the grammar to achieve this. If you write code to do so, you must submit it with your project.
\item \textbf{Make the grammar LL(1).} You must modify the grammar to ensure that it is LL(1). To this end, you are only allowed to modify the grammar by removing left recursion or performing left factoring. Again, you may manually modify the grammar by hand or write code that manipulates the grammar. In the latter case, you must submit the code you wrote.
\item \textbf{Generate a parser.} Input your grammar to ANTLR and generate a parser in the language of your choice (among Java, C++, C\#, and Python). Then test the parser by feeding it \emph{Tiger} programs which are used as test cases. Iterate and revise the grammar, repeating steps 1 and 2 until you get it right. The generated parser when invoked on an input \emph{Tiger} program will generate a parse tree which can be visualized with a suitable IDE plug-in (\url{http://www.antlr.org/tools.html}).
\end{enumerate}

For syntactically correct \emph{Tiger} programs, your program (which invokes the parser) should print \texttt{successful} to stdout. 
For programs with lexical or syntactic errors, ANTLR's lexer and parser will automatically detect and report them through their error listeners. You should provide custom error listeners that tag these messages appropriately:
\begin{itemize}
    \item Lexical errors will be reported as \texttt{[LexicalError] line <row>:<col> <msg>}
    \item Syntactic errors will be reported as \texttt{[SyntacticError] line <row>:<col> <msg>}
\end{itemize}
Use ANTLR's built-in error recovery mechanisms to print these messages and continue parsing gracefully when possible.

\section{Grading}

The total possible number of points for Project 3 is 100. Points are awarded according to the following rubric.

You must submit a single ZIP file that contains:
\begin{itemize}

    \item A grammar file named ``tiger.g4'' in the root directory.
    \item A directory named ``antlr\_generated'' which contains the ANTLR--generated lexer and parser for your grammar. It's fine if you leave this directory empty and regenerate its contents each time ``run.sh'' is run, but your report should indicate if this is the case.
    \item A file named ``run.sh'' in the root directory which runs your parser.
    \item Any other source code for your project, including any code you wrote to manipulate the grammar.
    \item Any new test cases you developed for the project in a directory named ``new\_test\_cases''.
    \item A document named ``report.pdf''.
\end{itemize}




\subsection{Correct grammar (35 points)}
You must submit a modified \emph{Tiger} grammar in the .g4 format. This grammar must be in a file named ``tiger.g4'' in the root directory of your submitted zip file. Points are allocated as follows.
\begin{itemize}
    \item Your grammar is not ambiguous (15 points)
    \item Your grammar is LL(1) (20 points)
\end{itemize}

\subsection{Correct lexer/parser (40 points)}
You must submit the ANTLR--generated lexer and parser for your project in a directory named ``antlr\_generated'' in the root of your ZIP file. You may leave this directory empty and regenerate its contents with ANTLR as part of your ``run.sh'' script---if you choose to do this, please document it in your report. If you do submit a parser the ``antlr\_generated'' directory, please include instructions on how to use ANTLR to regenerate your parser in your submitted \texttt{report.pdf}. In this case, \textbf{the parser you submit must be replicable.}

In addition, include a script named ``run.sh'' in the root directory of your submission which runs your parser. It should take a single argument, a \emph{Tiger} program and output to stdout either \texttt{successful} in the case that parsing was successful, or an appropriate error as described in Section~\ref{steps} if it was not. For example,
\begin{lstlisting}[]
$ run.sh path/to/correct_case.tiger
successful
\end{lstlisting}
This will be graded as follows.
\begin{itemize}
    \item Lexer prints reasonable error message for malformed \textit{Tiger} programs with lexical errors (10 points)
    \item Parser prints reasonable error message for malformed \textit{Tiger} programs with syntactic errors (15 points)
    \item Lexer/Parser doesn't report errors when provided with legal \textit{Tiger} programs (15 points)
\end{itemize}

Unlike projects 1 and 2, all of the test cases (\textit{Tiger} programs) for this project are public, available in the \texttt{test_cases} directory of the project repository.

Note that in some cases, a lexical error may also trigger subsequent syntactic errors during error handling and recovery. Such behavior is possible and acceptable, but you are responsible for verifying that your reported errors are reasonable and consistent with your grammar.

\subsection{Design report (25 Points)}\label{sec:design}

Your submission should include a document named ``report.pdf'' which briefly describes the following:
%
\begin{enumerate}
    \item A summary of your implementation strategy, including how you modified the \emph{Tiger} grammar to make it unambiguous and LL(1), e.g. how you identified and resolved ambiguities
    \item Which language you chose for your parser, and either an indication that your ``run.sh'' script recreates the contents of the ``antlr\_generated'' directory or instructions on how to regenerate the contents of that directory using ANTLR
    \item Software engineering challenges and issues that arose and how you resolved them
    \item Any known outstanding bugs or deficiencies that you were unable to resolve before the project submission
 \end{enumerate}

\section{Collaboration}

The collaboration policy and expectations are the same as in project 1.

\begin{appendices}

\section{\emph{Tiger} Language Reference Manual}\label{app:tiger}

\subsection{Grammar (syntactic rules)}\label{app:grammar}

\grammarindent=12em
\begin{grammar}
<tiger-program> ::=  `main' `let' <declaration-segment> `in' `begin' <stat-seq> `end'

<declaration-segment> ::= <var-declaration-list> <funct-declaration-list>

<var-declaration-list> ::= <empty>

<var-declaration-list> ::= <var-declaration> <var-declaration-list>

<var-declaration> ::= `var' <id-list> `:' <type> <optional-init> `;'

<funct-declaration-list> ::= <empty>

<funct-declaration-list> ::= <funct-declaration> <funct-declaration-list>

<funct-declaration> ::= `function' "ID" `(' <param-list> `)' <ret-type> `begin' <stat-seq> `end'

<type> ::= <type-id>

<type> ::= `array' `[' "INTLIT" `]' `of' <type-id>

<type-id> ::= `int' | `float'

<id-list> ::= "ID"

<id-list> ::= "ID" `,' <id-list>

<optional-init> ::= <empty>

<optional-init> ::= `:=' <const>

<param-list> ::= <empty>

<param-list> ::= <param> <param-list-tail>

<param-list-tail> ::= <empty>

<param-list-tail> ::= `,' <param> <param-list-tail>

<ret-type> ::= <empty>

<ret-type> ::= `:' <type>

<param> ::= "ID" `:' <type>

<stat-seq> ::= <stat>

<stat-seq> ::= <stat> <stat-seq>

<stat> ::= <lvalue> `:=' <expr> `;'

<stat> ::= `if' <expr> `then' <stat-seq> `endif' `;'

<stat> ::= `if' <expr> `then' <stat-seq> `else' <stat-seq> `endif' `;'

<stat> ::= `while' <expr> `do' <stat-seq> `enddo' `;'

<stat> ::= `for' "ID" `:=' <expr> `to' <expr> `do' <stat-seq> `enddo' `;'

<stat> ::= <opt-prefix> "ID" `(' <expr-list> `)' `;'

<opt-prefix> ::= <lvalue> `:='

<opt-prefix> ::= <empty>

<stat> ::= `break' `;'

<stat> ::= `return' <expr> `;'

<stat> ::= `let' <declaration-segment> `in' <stat-seq> `end'

<expr> ::= <const>
    \alt <lvalue>
    \alt <expr> <binary-operator> <expr>
    \alt `(' <expr> `)'
    
<const> ::= "INTLIT"

<const> ::= "FLOATLIT"

<binary-operator> ::= `+' | `-' | `*' | `/' | `=' | `<>' | `<' | `>' | `<=' | `>=' | `\&' | `|'

<expr-list> ::= <empty>

<expr-list> ::= <expr> <expr-list-tail>

<expr-list-tail> ::= `,' <expr> <expr-list-tail>

<expr-list-tail> ::= <empty>

<lvalue> ::= "ID" <lvalue-tail>

<lvalue-tail> ::= `[' <expr> `]'

<lvalue-tail> ::= <empty>
\end{grammar}

\subsubsection{Precedence (Highest to Lowest)}
\begin{verbatim}
( )  *  /  +  -  =  <>  > <  >=  <=  &  |
\end{verbatim}

\subsubsection{Associativity}

Binary operators are \textbf{right associative}.

\subsection{Lexical Rules}\label{app:lexical}

\subsubsection{Case Sensitivity}
\emph{Tiger} is a case-sensitive language.

\subsubsection{Identifier (ID)}
An identifier is a sequence of one or more letters, digits, and underscores.
It must start with a letter, followed by zero or more of letter, digit or underscore.

\subsubsection{Comment}
A comment begins with ``/*'' and ends with ``*/''. Nesting is not allowed.

\subsubsection{Integer Literal (INTLIT)}
An integer literal is a non-empty sequence of digits.

\subsubsection{Float Literal (FLOATLIT)}
A float literal must consist of a non-empty sequence of digits, a radix (i.e., a decimal point),
and a (possibly empty) sequence of digits.

\subsubsection{Reserved (Key)words}
\begin{tabular} {c c c c c c c c c}
main & array & break & do & if & else & for \\ function & let & in & of & then & to & var \\
while & endif & begin & end & enddo & return \\ int & float
\end{tabular}

\subsubsection{Punctuation Symbols}
\begin{verbatim}
,  :  ;  (  )  [  ]
\end{verbatim}

\subsubsection{Binary Operators}
\begin{verbatim}
+  -  *  /  =  <>  <  >  <=  >=  &  |
\end{verbatim}

\subsubsection{Assignment operator}
\begin{verbatim}
:=
\end{verbatim}

\end{appendices}

\end{document}
