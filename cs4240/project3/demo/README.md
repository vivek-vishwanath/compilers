# Overview
`ANTLR` is a commercial tool that generates lexer & parser for a given input grammar.
In project 3, you will use `ANTLR` to generate lexer & parser for the Tiger programming language.

The lexical & syntactic rules for the *Tiger* programming language are provided in the appendix of the project document,
and you will have to rewrite the grammar in order to remove ambiguities in the grammar and make it an LL(1) grammar.

# Installing and setting up ANTLR (UNIX)
Note that you can also follow the instructions below on Windows using [`git bash for windows`](https://www.educative.io/edpresso/how-to-install-git-bash-in-windows).

1. Install Java & Javac (version 1.6 or higher).
   For teams that plan to use other programming languages, please refer to the [ANTLR download page](https://www.antlr.org/download.html) for more details.
2. Download `ANTLR-4.13.2` to the current directory
```
$ curl -O https://www.antlr.org/download/antlr-4.13.2-complete.jar
```
Or just download from [https://www.antlr.org/download.html](https://www.antlr.org/download.html). 

Create aliases for the `ANTLR` Tool, and `TestRig` (for convenience)
```bash
# UNIX-based platforms:
$ alias antlr4='java -Xmx500M -cp "./antlr-4.13.2-complete.jar:$CLASSPATH" org.antlr.v4.Tool'
$ alias grun='java -Xmx500M -cp "./antlr-4.13.2-complete.jar:./build:$CLASSPATH" org.antlr.v4.gui.TestRig'
# Windows:
$ alias antlr4='java -Xmx500M -cp "./antlr-4.13.2-complete.jar\;$CLASSPATH" org.antlr.v4.Tool'
$ alias grun='java -Xmx500M -cp "./antlr-4.13.2-complete.jar\;./build\;$CLASSPATH" org.antlr.v4.gui.TestRig'
```
* `TestRig` a flexible command line tool that lets you to test your lexer & parser (generated by ANTLR) on an input test case. It displays information about how a recognizer matches input from a file or standard input.

# A Simple Arithmetic Expression Language
An ANTLR4 grammar file(.g4) contains both lexical rules and parser rules. Rules starting with an uppercase letter comprise the `lexical (token) rules`. Rules starting with a lowercase letter comprise the `parser rules`. Alternatives of a rule are separated with the | operator, and we can group symbols with parentheses into subrules. For example, subrule ('*'|'/') matches either a multiplication symbol or a division symbol. The expression grammar is specified in `Expr.g4`, and correct and incorrect example strings belonging to the language are provided in `exprs`.


# Running ANTLR on the grammar
Running the ANTLR tool on Expr.g4 generates a `Lexer` and a `Parser` (as Java source files) for the grammar specified in `Expr.g4`. Here we place all the generated files under the `./antlr_generated` folder.

```bash
$ antlr4 Expr.g4 -o ./antlr_generated
```
Under the `./antlr_generated` directory, `ExprLexer.java` is the generated lexer and `ExprParser.java` is the generated parser for the `Expr` grammar (`Expr.g4`).

Let's compile the source files generated by ANTLR.
All generated source files' names take the grammar file's name (`Expr` in this case) as a prefix. Therefore, we can compile the generated source files by invoking `javac` as below.
```bash
# UNIX-based platforms
$ javac -cp "./antlr-4.13.2-complete.jar:$CLASSPATH" ./antlr_generated/Expr*.java -d ./build
# Windows
$ javac -cp "./antlr-4.13.2-complete.jar\;$CLASSPATH" ./antlr_generated/Expr*.java -d ./build
```

# Using the TestRig tool (alias 'grun')

The TestRig tool can help you test your lexer & parser. You can see a full list of the tools' options as follows:

```
$ grun
java org.antlr.v4.gui.TestRig GrammarName startRuleName
  [-tokens] [-tree] [-gui] [-ps file.ps] [-encoding encodingname]
  [-trace] [-diagnostics] [-SLL]
  [input-filename(s)]
Use startRuleName='tokens' if GrammarName is a lexer grammar.
Omitting input-filename makes rig read from stdin.
```
Some useful options include:
* -tree : print the parse tree in LISP-style text form (root children).
* -tokens : prints out the token stream.
* -gui : pops up a new window with a graphical visualization of the parse tree.

To test the correct sample input, run the following:

```
$ grun Expr prog -tree -tokens exprs/correct.expr
[@0,0:2='193',<INT>,1:0]
[@1,3:3='\n',<NEWLINE>,1:3]
[@2,4:4='a',<ID>,2:0]
[@3,6:6='=',<'='>,2:2]
[@4,8:8='5',<INT>,2:4]
[@5,9:9='\n',<NEWLINE>,2:5]
[@6,10:10='a',<ID>,3:0]
[@7,11:11='+',<'+'>,3:1]
[@8,12:12='b',<ID>,3:2]
[@9,13:13='*',<'*'>,3:3]
[@10,14:14='2',<INT>,3:4]
[@11,15:15='\n',<NEWLINE>,3:5]
[@12,16:16='(',<'('>,4:0]
[@13,17:17='1',<INT>,4:1]
[@14,18:18='+',<'+'>,4:2]
[@15,19:19='2',<INT>,4:3]
[@16,20:20=')',<')'>,4:4]
[@17,21:21='*',<'*'>,4:5]
[@18,22:22='3',<INT>,4:6]
[@19,23:23='\n',<NEWLINE>,4:7]
[@20,24:23='<EOF>',<EOF>,5:0]
(prog (stat (expr 193) \n) (stat a = (expr 5) \n) (stat (expr (expr a) + (expr (expr b) * (expr 2))) \n) (stat (expr (expr ( (expr (expr 1) + (expr 2)) )) * (expr 3)) \n))
```

And for the incorrect input, ANTLR parsers can report and recover from syntax errors, as shown below.

```
$ grun Expr prog -tokens -gui exprs/incorrect.expr
line 2:3 token recognition error at: '^'
[@0,0:0='a',<ID>,1:0]
[@1,2:2='=',<'='>,1:2]
[@2,4:4='\n',<NEWLINE>,1:4]
[@3,5:5='a',<ID>,2:0]
[@4,6:6='+',<'+'>,2:1]
[@5,7:7='b',<ID>,2:2]
[@6,9:9='2',<INT>,2:4]
[@7,10:10='\n',<NEWLINE>,2:5]
[@8,11:10='<EOF>',<EOF>,3:0]
line 1:4 extraneous input '\n' expecting {'(', ID, INT}
line 2:4 extraneous input '2' expecting NEWLINE
```

# Overview of project objectives

### Writing the Driver code for importing & invoking the generated lexer & parser
For Project 3, you need to write a main program that imports the generated lexer & parser to parse an input test case.

Upon successful parse, your program should output ``successful`` to stdout. Since the ANTLR generated lexer and parser don't print anything to stdout upon successful parse, you must write code that checks whether there were any errors during parsing.

You may find the API documentation for the following classes useful for this step.
* [`org.antlr.v4.runtime.Parser`](https://www.antlr.org/api/Java/org/antlr/v4/runtime/Parser.html)
* [`org.antlr.v4.runtime.BaseErrorListener`](https://www.antlr.org/api/Java/org/antlr/v4/runtime/BaseErrorListener.html)

### Removing Ambiguity in the grammar 
Note that for an input expression `a + b + c`, the `Expr` grammar can derive two distinct parse trees for the same input.
If a grammar can derive more than one distinct parse tree for the same input, the grammar is an ambiguous grammar.
```
# 1st parse tree                      # 2nd parse tree

            prog                                prog
              |                                  |
            stat                                stat
            /  \                               /    \           
          expr  NEWLINE                     expr    NEWLINE
         / | \                             /  | \ 
        a  +  expr                      expr  +  c
             / | \                      / | \
            b  +  c                    a  +  b
```

In Project 3, you have to remove all ambiguities in the `Tiger` grammar by rewriting the grammar without altering its semantics.

### Fixing a grammar to be LL(1)
In addition, for Project 3, you have to modify the `Tiger` grammar to make the grammar LL(1) without altering its semantics. This is a step you should do manually, and you should use what you have learned in class to verify that your grammar is indeed LL(1). However, you may also find the following informal trick helpful as a final check that your grammar is LL(1). This is a useful double check, but not a guarantee.

Suppose that your grammar file is `Tiger.g4`. Then use antlr to generate the parser code in Java (`out` is the output directory):
```
antlr4 Tiger.g4 -o ./out
```

Search for "adaptivePredict" in the generated code:
```
grep -r "adaptivePredict" ./out
```

If the output is non-empty, your grammar is not LL(1). The name of the function that contains the occurrence is typically `XXXContext` where the `XXX` part might give you a rough idea what part of your grammar is not LL(1).
